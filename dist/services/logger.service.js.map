{"version":3,"file":"logger.service.js","sourceRoot":"","sources":["../../src/services/logger.service.ts"],"names":[],"mappings":"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","sourcesContent":["import {ListItem} from '../factories';\nimport {isFunction, includes} from 'lodash';\n\nexport class LogEvent implements ILogEvent {\n    message: string;\n    promise: Promise<ListItem<any>>;\n    type: string;\n    url: string;\n    constructor(options: ILogEvent, type: string, message: string) {\n        this.type = type;\n        this.message = message;\n        this.url = location.href;\n        // create a promise to pass back to caller to monitor log creation\n        this.promise = new Promise((resolve, reject) => {\n            this._resolve = resolve;\n        });\n        // extend object with any additional attributes\n        Object.assign(this, options);\n        // generate notification\n        registerEvent(this);\n    }\n    // called once the log has been created with the log list item\n    _resolve: (any);\n}\n\nexport interface ILogEvent {\n    cause?: string;\n    event?: string;\n    json?: Object;\n    message?: string;\n    stackTrace?: string[];\n    type?: string;\n    // initial URL and URL after and routing has settled\n    url?: string;\n}\nlet eventQueue: ILogEvent[] = [];\nlet subscribers: Function[] = [];\n\nexport interface ILoggerService {\n    eventQueue: ILogEvent[];\n    subscribers: Function[];\n\n    debug(message: string, optionsOverride?: ILogEvent): Promise<ListItem<any>>;\n    error(message: string, optionsOverride?: ILogEvent): Promise<ListItem<any>>;\n    exception(exception: Error, cause?: string, optionsOverride?: ILogEvent): void;\n    info(message: string, optionsOverride?: ILogEvent): Promise<ListItem<any>>;\n    log(message: string, optionsOverride?: ILogEvent): Promise<ListItem<any>>;\n    registerEvent(logEvent: ILogEvent): void;\n    subscribe(callback: Function): void;\n    warn(message: string, optionsOverride?: ILogEvent): Promise<ListItem<any>>;\n}\n\nexport let LoggerService: ILoggerService = {\n    eventQueue,\n    subscribers,\n    debug,\n    error,\n    exception,\n    info,\n    log,\n    registerEvent,\n    subscribe,\n    warn\n};\n\n/**\n * @ngdoc service\n * @name angularPoint.LoggerService\n * @description\n * Common definitions used in the application.\n *\n * HOW TO USE\n * 1. Create a logging model for logs to be stored\n * 2. Ensure everyone has write access to the list\n * 3. Add the model as one of the dependencies in your .run so it'll be instantiated immediately\n * 4. Subscribe to change events from on the model\n *\n *\n * @example\n * <pre>\n * export class Log extends ap.ListItem{\n *     cause: string;\n *     event: string;\n *     formattedStackTrace: string;\n *     json: Object;\n *     message: string;\n *     stackTrace: string[];\n *     type: string;\n *     url: string;\n *     constructor(obj){\n *         Object.assign(this, obj);\n *     }\n *     //override the default save and cleanup before actually saving\n *     saveChanges() {\n *          // stringify stacktrace prior to saving so we can display in email notifications\n *          if(this.stackTrace && !this.formattedStackTrace) {\n *          this.formattedStackTrace = this.stackTrace.map(function(sf) {\n *               return sf.toString();\n *           }).join('\\n');\n *         }\n *         return super.saveChanges();\n *     }\n * }\n * var logCounter = 0;\n * var maxLogsPerSesssion = 5;\n * export class LogsModel extends ap.ListService{\n *     constructor(apLogger: ap.Logger) {\n *         model = this;\n *         super({\n *             factory: Log,\n *             list: {\n *                 title: 'Logs',\n *                 guid: '{LOG LIST GUID...CHANGE ME}',\n *                 customFields: [\n *                     {staticName: 'Message', objectType: 'Note', mappedName: 'message', readOnly: false},\n *                     {staticName: 'Title', objectType: 'Text', mappedName: 'url', readOnly: false},\n *                     {staticName: 'LogType', objectType: 'Text', mappedName: 'type', readOnly: false},\n *                     {staticName: 'StackTrace', objectType: 'JSON', mappedName: 'stackTrace', readOnly: false},\n *                     {staticName: 'Cause', objectType: 'Text', mappedName: 'cause', readOnly: false},\n *                     {staticName: 'JSON', objectType: 'JSON', mappedName: 'json', readOnly: false},\n *                     {staticName: 'Event', objectType: 'Text', mappedName: 'event', readOnly: false},\n *                     {\n *                         staticName: 'FormattedStackTrace',\n *                         objectType: 'Note',\n *                         mappedName: 'formattedStackTrace',\n *                         readOnly: false,\n *                         description: 'Trace formatted to be readable in email notification.'\n *                     }\n *                 ]\n *             }\n *         });\n *         // Register this model as the list where all logs will be stored\n *         apLogger.subscribe(function (event: ap.ILogEvent) {\n *             // Ensure we keep logging under control, prevents spamming server if loop occurs\n *             if(logCounter < maxLogsPerSesssion) {\n *                 var newLog = model.createEmptyItem(event);\n *                 console.log(newLog);\n *                 newLog.saveChanges();\n *                 logCounter++;\n *             }\n *         });\n *     }\n * }\n *\n * </pre>\n *\n */\n\n\n/**\n * @ngdoc function\n * @name angularPoint.apLogger.debug\n * @methodOf angularPoint.apLogger\n * @param {string} message Message to log.\n * @param {ILogger} [optionsOverride] Override any log options.\n */\nfunction debug(message: string, optionsOverride: ILogEvent = {}): Promise<ListItem<any>> {\n    let logEvent = new LogEvent(optionsOverride, 'debug', message);\n    return logEvent.promise;\n}\n\n/**\n * @ngdoc function\n * @name angularPoint.apLogger.error\n * @methodOf angularPoint.apLogger\n * @param {string} message Message to log.\n * @param {ILogger} [optionsOverride] Override any log options.\n */\nfunction error(message: string, optionsOverride?: ILogEvent): Promise<ListItem<any>> {\n    let logEvent = new LogEvent(optionsOverride, 'error', message);\n    return logEvent.promise;\n}\n\n// declare module ErrorStackParser {\n//     export interface parse{\n//         (any): string;\n//     }\n// }\n\n/**\n * @ngdoc function\n * @name angularPoint.apLogger.exception\n * @methodOf angularPoint.apLogger\n * @param {Error} exception Error which caused event.\n * @param {string} [cause] Angular sometimes provides cause.\n * @param {ILogger} optionsOverride Override any log options.\n */\nfunction exception(exception: Error, cause?: string, optionsOverride?: ILogEvent): void {\n    let defaults = {\n        event: 'exception',\n        stackTrace: undefined,\n        cause: (cause || '')\n    }\n    console.info('Need to do something with error', error);\n    // try {\n    //     // generate a stack trace\n    //     /* global ErrorStackParser:true */\n    //     var stackTrace = ErrorStackParser.parse(exception);\n    //     defaults.stackTrace = stackTrace;\n\n    // } catch (loggingError) {\n    //     let notification = 'Error server-side logging failed so unable to generate notification.';\n    //     console.warn(notification);\n    //     console.log(loggingError);\n    //     defaults.stackTrace = notification;\n    // }\n\n    error(exception.message, Object.assign({}, defaults, optionsOverride));\n\n}\n\n/**\n * @ngdoc function\n * @name angularPoint.apLogger.info\n * @methodOf angularPoint.apLogger\n * @param {string} message Message to log.\n * @param {ILogger} [optionsOverride] Override any log options.\n */\nfunction info(message: string, optionsOverride?: ILogEvent): Promise<ListItem<any>> {\n    let logEvent = new LogEvent(optionsOverride, 'info', message);\n    return logEvent.promise;\n}\n\n/**\n * @ngdoc function\n * @name angularPoint.apLogger.log\n * @methodOf angularPoint.apLogger\n * @param {string} message Message to log.\n * @param {ILogger} [optionsOverride] Override any log options.\n */\nfunction log(message: string, optionsOverride?: ILogEvent): Promise<ListItem<any>> {\n    let logEvent = new LogEvent(optionsOverride, 'log', message);\n    return logEvent.promise;\n};\n\nfunction registerEvent(logEvent: ILogEvent): void {\n    eventQueue.push(logEvent);\n    processEventQueue();\n}\n\n/**\n * @ngdoc function\n * @name angularPoint.apLogger.subscribe\n * @methodOf angularPoint.apLogger\n * @param {Function} callback Register subscription with a callback function that is notified each time an event occurs.\n * @description Callback fired when log event occurs\n */\nfunction subscribe(callback: () => ILogEvent): void {\n    if (!isFunction(callback)) {\n        throw new Error('A callback function was expected but not provided.');\n    }\n// only add to subscribers if it not already there\n    if (!includes(subscribers, callback)) {\n        subscribers.push(callback);\n    }\n    processEventQueue();\n}\n\n/**\n * @ngdoc function\n * @name angularPoint.apLogger.warn\n * @methodOf angularPoint.apLogger\n * @param {string} message Message to log.\n * @param {ILogger} [optionsOverride] Override any log options.\n */\nfunction warn(message: string, optionsOverride?: ILogEvent): Promise<ListItem<any>> {\n    let logEvent = new LogEvent(optionsOverride, 'warn', message);\n    return logEvent.promise;\n}\n\nfunction processEventQueue() {\n    // iterate over each subscriber and notify for each event in the queue\n    for (let callback of subscribers) {\n        for (let event of eventQueue) {\n            callback(event);\n        }\n    }\n}\n"]}