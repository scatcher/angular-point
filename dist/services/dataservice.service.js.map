{"version":3,"file":"dataservice.service.js","sourceRoot":"","sources":["../../src/services/dataservice.service.ts"],"names":[],"mappings":"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","sourcesContent":["\nimport {Injectable} from \"@angular/core\";\nimport {Http, RequestOptions, Request, RequestMethod, Headers} from \"@angular/http\";\nimport {Observable} from 'rxjs/Observable';\n\nimport {XMLFieldDefinition} from \"../factories/field-definition.factory\";\nimport {IXMLGroup, IXMLUserProfile} from \"./user-profile.service\";\nimport {checkResponseForErrors, parseFieldVersions, extendListMetadata} from \"./decode.service\";\nimport {generateXMLComponents} from \"./spservices.service\";\nimport {getHttp} from '../factories/http-provider.factory';\nimport {\n    WebServiceOperationConstants,\n    AP_CONFIG,\n    BasePermissionObject,\n    SCHEMASharePoint,\n    IUserPermissionsObject\n} from \"../constants\";\nimport {LoggerService, xmlToJSONService} from \"../services\";\nimport {\n    ListItem,\n    ListService,\n    Query,\n    FieldDefinition,\n    IFieldDefinition,\n    SOAPEnvelope,\n    FieldVersionCollection\n} from \"../factories\";\n\nimport {each, isString} from 'lodash';\n\n\nexport interface IDataService {\n    currentSite$: Observable<string>;\n    createItemUrlFromFileRef(fileRefString: string): string;\n    generateWebServiceUrl(service: string, webURL: string): string;\n    getAvailableWorkflows(fileRefString: string): Observable<IWorkflowDefinition[]>;\n    getCollection(options: { operation: string; userLoginName?: string; groupName?: string; listName?: string; filterNode: string; }): Observable<Object[]>;\n    getFieldVersionHistory<T extends ListItem<any>>(options: IGetFieldVersionHistoryOptions, fieldDefinition: FieldDefinition): Observable<FieldVersionCollection>;\n    getGroupCollectionFromUser(login?: string): Observable<IXMLGroup[]>;\n    getList(options: { listName: string; webURL?: string }): Observable<Object>;\n    getListFields(options: {listName: string, webURL?: string}): Observable<XMLFieldDefinition[]>\n    getUserProfileByName(login?: string): Observable<IXMLUserProfile>;\n    processChangeTokenXML<T extends ListItem<any>>(model: ListService<T>, query: Query<T>, responseXML: Element, opts): void;\n    getDeletionIdsSinceToken(responseXML: Element): number[];\n    requestData(opts): Observable<Document>;\n    retrieveChangeToken(responseXML: Element): string;\n    retrieveListPermissions(responseXML: Element): IUserPermissionsObject;\n    serviceWrapper(options): Observable<any>;\n    startWorkflow(options: { item: string; templateId: string; workflowParameters?: string; fileRef?: string; }): Observable<any>;\n}\n\n@Injectable()\nexport class DataService implements IDataService {\n    // Cold observable that turns hot at first subscription\n    currentSite$: Observable<string> = Observable.create(observer => {\n        let soapEnvelope = new SOAPEnvelope();\n        let soapData = soapEnvelope.header +\n            `<WebUrlFromPageUrl xmlns=\"${SCHEMASharePoint}/soap/\" ><pageUrl>` +\n            ((location.href.indexOf('?') > 0) ? location.href.substr(0, location.href.indexOf('?')) : location.href) +\n            `</pageUrl></WebUrlFromPageUrl>` +\n            soapEnvelope.footer;\n\n        let headers = new Headers({ 'Content-Type': `text/xml;charset='utf-8'` });\n\n        let options = new RequestOptions({\n            method: RequestMethod.Post,\n            url: '/_vti_bin/Webs.asmx',\n            body: soapData,\n            headers\n        });\n\n        let requestOptions = new Request(options);\n\n        this.http\n            .request(requestOptions)\n            .map(response => {\n                let parser = new DOMParser();\n                let responseXML = parser.parseFromString(response.text(), 'application/xml');\n\n                /** Success */\n                let errorMsg = checkResponseForErrors(responseXML);\n                if (errorMsg) {\n                    errorHandler('Failed to get current site.  ' + errorMsg, soapData);\n                }\n\n                let defaultUrl = responseXML.getElementsByTagName('WebUrlFromPageUrlResult');\n                if (!defaultUrl[0]) {\n                    throw new Error('Invalid XML returned, missing \"WebUrlFromPageUrlResult\" element.');\n                }\n                return defaultUrl[0].textContent;\n            })\n            .subscribe(url => {\n                AP_CONFIG.defaultUrl = url;\n                observer.next(url);\n                observer.complete();\n            }, err => {\n                /** Error */\n                errorHandler('Failed to get current site.  ' + err, soapData);\n            });\n\n    });\n    http: Http;\n    constructor(http: Http) {\n        /*\n         * Mock Http service is only available in development environment\n         */\n        this.http = getHttp(http);\n        // this.http = mockHttp || http;\n    }\n\n    createItemUrlFromFileRef(fileRefString: string): string {\n        return window.location.protocol + '//' + window.location.hostname + '/' + fileRefString;\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.generateWebServiceUrl\n     * @description\n     * Builds the appropriate SharePoint resource URL.  If a URL isn't provided and it hasn't already been cached\n     * we make a call to the server to find the root URL.  All future requests will then use this cached value.\n     * @param {string} service The name of the service the SOAP operation is using.\n     * @param {string} webURL Provide the URL so we don't need to make a call to the server.\n     * @returns {string} Resolves with the url for the service.\n     */\n    generateWebServiceUrl(service: string, webURL: string): string {\n        let ajaxURL = `_vti_bin/${service}.asmx`;\n        return webURL.charAt(webURL.length - 1) === '/' ?\n            webURL + ajaxURL : webURL + '/' + ajaxURL;\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.getAvailableWorkflows\n     * @description\n     * Given a list item or document, return an array of all available workflows.  This is used in combination with\n     * DataService.startWorkflow because it requires the template GUID for the target workflow.\n     * @example\n     * <pre>\n     * DataService.getAvailableWorkflows(listItem.fileRef.lookupValue)\n     *     .subscribe(function(templateArray) {\n     *          ....templateArray = [{\n     *              \"name\": \"WidgetApproval\",\n     *              \"instantiationUrl\": \"https: //sharepoint.mycompany.com/_layouts/IniWrkflIP.aspx?List=fc17890e-8c0…311-cea9-40d1-a183-6edde9333815}&Web={ec744d8e-ae0a-45dd-bcd1-8a63b9b399bd}\",\n     *              \"templateId\": \"59062311-cea9-40d1-a183-6edde9333815\"\n     *          }]\n     *     });\n     * </pre>\n     * @param {string} fileRefString Relative or static url referencing the item.\n     * @returns {Observable<IWorkflowDefinition[]} Resolves with an array of objects defining each of the available workflows for the item.\n     */\n    getAvailableWorkflows(fileRefString: string): Observable<IWorkflowDefinition[]> {\n        /** Build the full url for the fileRef if not already provided.  FileRef for an item defaults to a relative url */\n        let itemUrl = fileRefString.includes(': //') ? fileRefString : this.createItemUrlFromFileRef(fileRefString);\n\n        return this\n            .serviceWrapper({\n                operation: 'GetTemplatesForItem',\n                item: itemUrl\n            })\n            .map((responseXML: Element) => {\n                let workflowTemplates = [];\n                let xmlTemplates = responseXML.getElementsByTagName('WorkflowTemplate');\n                each(xmlTemplates, (el: Element) => {\n                    let workflowTemplateId = el.getElementsByTagName('WorkflowTemplateIdSet')[0].getAttribute('TemplateId');\n                    let template = {\n                        name: el.getAttribute('Name'),\n                        instantiationUrl: el.getAttribute('InstantiationUrl'),\n                        templateId: '{' + workflowTemplateId + '}'\n                    };\n                    workflowTemplates.push(template);\n                });\n                return workflowTemplates;\n            });\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.getCollection\n     * @description\n     * Used to handle any of the Get[filterNode]Collection calls to SharePoint\n     *\n     * @param {Object} options - object used to extend payload and needs to include all SPServices required attributes\n     * @param {string} options.operation Can be any of the below or any other requests for collections:\n     *  - GetAttachmentCollection @requires options.listName & options.ID\n     *  - GetGroupCollectionFromSite\n     *  - GetGroupCollectionFromUser @requires options.userLoginName\n     *  - GetListCollection\n     *  - GetUserCollectionFromGroup @requires options.groupName\n     *  - GetUserCollectionFromSite\n     *  - GetViewCollection @requires options.listName\n     * @param {string} options.filterNode Value to iterate over in returned XML\n     *         if not provided it's extracted from the name of the operation\n     *         ex: Get[User]CollectionFromSite, \"User\" is used as the filterNode\n     * @param {string} [options.groupName] Valid for 'GetUserCollectionFromGroup'\n     * @param {string} [options.listName] Valid for 'GetViewCollection' or 'GetAttachmentCollection'\n     * @param {string} [options.userLoginName] Valid for 'GetGroupCollectionFromUser'\n     * @returns {Observable<object[]>} Observable which when resolved will contain an array of objects representing the\n     * requested collection.\n     *\n     * @example\n     * <pre>\n     * DataService.getCollection({\n     *        operation: \"GetGroupCollectionFromUser\",\n     *        userLoginName: $scope.state.selectedUser.LoginName\n     *        }).subscribe(response => {\n     *            postProcessFunction(response);\n     *       });\n     * </pre>\n     */\n    getCollection(options: IGetCollectionOptions): Observable<Object[]> {\n        let defaults = {\n            postProcess: processColectionXML\n        };\n        let opts: IGetCollectionOptions = Object.assign({}, defaults, options);\n\n        /** Determine the XML node to iterate over if filterNode isn't provided */\n        let filterNode = opts.filterNode || opts.operation.split('Get')[1].split('Collection')[0];\n\n        /** Convert the xml returned from the server into an array of js objects */\n        function processColectionXML(responseXML: Element) {\n            let convertedItems: Object[] = [];\n            let filteredNodes = responseXML.getElementsByTagName(filterNode);\n            /** Get attachments only returns the links associated with a list item */\n            if (opts.operation === 'GetAttachmentCollection') {\n                /** Unlike other call, get attachments only returns strings instead of an object with attributes */\n                each(filteredNodes, (node: Element) => {\n                    convertedItems.push(node.textContent);\n                });\n            } else {\n                convertedItems = xmlToJSONService.parse(filteredNodes, { includeAllAttrs: true, removeOws: false });\n            }\n            return convertedItems;\n        }\n\n        return this.serviceWrapper(opts);\n\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name DataService.getFieldVersionHistory\n     * @description\n     * Returns the version history for a field in a list item.\n     * @param {object} options Configuration object passed to SPServices.\n     * <pre>\n     * let options = {\n     *        operation: 'GetVersionCollection',\n     *        webURL: AP_CONFIG.defaultUrl,\n     *        strlistID: model.getListId(),\n     *        strlistItemID: listItem.id,\n     *        strFieldName: fieldDefinition.staticName\n     *    };\n     * </pre>\n     * @param {object} fieldDefinition Field definition object from the model.\n     * @returns {Observable<object[]>} Observable which resolves with an array of list item changes for the specified field.\n     */\n    getFieldVersionHistory<T extends ListItem<any>>(options: IGetFieldVersionHistoryOptions,\n        fieldDefinition: IFieldDefinition): Observable<FieldVersionCollection> {\n        let defaults = {\n            operation: 'GetVersionCollection'\n        };\n        let opts = Object.assign({}, defaults, options);\n\n        return this.serviceWrapper(opts)\n            .map(response => {\n                /** Parse XML response */\n                let fieldVersionCollection = parseFieldVersions(response, fieldDefinition);\n                /** Resolve with an array of all field versions */\n                return fieldVersionCollection;\n            });\n        // .catch(err => `Failed to fetch version history. Error: ${err}`);\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.getGroupCollectionFromUser\n     * @description\n     * Fetches an array of group names the currentPerson is a member of.  If no currentPerson is provided we use the current currentPerson.\n     * @param {string} [login=CurrentUser] Optional param of another currentPerson's login to return the profile for.\n     * @returns {Observable<string[]>} Observable which resolves with the array of groups the currentPerson belongs to.\n     */\n    getGroupCollectionFromUser(login?: string): Observable<IXMLGroup[]> {\n\n        if (!login) {\n            /** No login name provided so lookup profile for current currentPerson */\n            return this.getUserProfileByName()\n                .map(userProfile => {\n                    return this.serviceWrapper({\n                        operation: 'GetGroupCollectionFromUser',\n                        userLoginName: userProfile.userLoginName,\n                        filterNode: 'Group'\n                    })\n                })\n                .flatMap(groupCollection => groupCollection);\n\n        } else {\n            return this.serviceWrapper({\n                operation: 'GetGroupCollectionFromUser',\n                userLoginName: login,\n                filterNode: 'Group'\n            })\n        }\n\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.getList\n     * @description\n     * Returns all list details including field and list config.\n     * @param {object} options Configuration parameters.\n     * @param {string} options.listName GUID of the list.\n     * @param {string} [options.webURL] URL to the site containing the list if differnt from primary data site in APConfig.\n     * @returns {Observable<Object>} Observable which resolves with an object defining field and list config.\n     */\n    getList({listName, webURL = undefined}): Observable<Object> {\n        return this.serviceWrapper({\n            operation: 'GetList',\n            listName,\n            webURL\n        });\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.getListFields\n     * @description\n     * Returns field definitions for a specified list.\n     * @param {object} options Configuration parameters.\n     * @param {string} options.listName GUID of the list.\n     * @param {string} [options.webURL] URL to the site containing the list if differnt from primary data site in APConfig.\n     * @returns {Observable<XMLFieldDefinition[]>} Observable which resolves with an array of field definitions for the list.\n     */\n    getListFields({listName, webURL = undefined}): Observable<XMLFieldDefinition[]> {\n        return this.getList({ listName, webURL })\n            .map((responseXML: Element) => {\n                let filteredNodes = responseXML.getElementsByTagName('Field');\n                let fields = xmlToJSONService.parse(filteredNodes, { includeAllAttrs: true, removeOws: false });\n                return fields;\n            });\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.getUserProfile\n     * @description\n     * Returns the profile for an optional user, but defaults the the current user if one isn't provided.\n     * Pull user profile info and parse into a profile object\n     * http://spservices.codeplex.com/wikipage?title=GetUserProfileByName\n     * @param {string} [login=CurrentUser] Optional param of another user's login to return the profile for.\n     * @returns {Observable<IXMLUserProfile>} Observable which resolves with the requested user profile.\n     */\n    getUserProfileByName(login?: string): Observable<IXMLUserProfile> {\n        let payload = {\n            accountName: undefined,\n            operation: 'GetUserProfileByName'\n        };\n        if (login) {\n            payload.accountName = login;\n        }\n\n        return this.serviceWrapper(payload)\n            .map((responseXML: Element) => {\n                let userProfile = {\n                    AccountName: undefined,\n                    userLoginName: undefined\n                };\n                // not formatted like a normal SP response so need to manually parse\n                let filteredNodes = responseXML.getElementsByTagName('PropertyData');\n                each(filteredNodes, (node: Element) => {\n                    let nodeName = node.getElementsByTagName('Name');\n                    let nodeValue = node.getElementsByTagName('Value');\n\n                    if (nodeName.length > 0 && nodeValue.length > 0) {\n                        userProfile[nodeName[0].textContent.trim()] = nodeValue[0].textContent.trim();\n                    }\n                });\n\n                /** Optionally specify a necessary prefix that should appear before the currentPerson login */\n                userProfile.userLoginName = AP_CONFIG.userLoginNamePrefix ?\n                    (AP_CONFIG.userLoginNamePrefix + userProfile.AccountName) : userProfile.AccountName;\n                return userProfile;\n            });\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.processChangeTokenXML\n     * @description\n     * The initial call to GetListItemChangesSinceToken also includes the field definitions for the\n     * list so extend the existing field definitions and list defined in the listService.  After that, store\n     * the change token and make any changes to the currentPerson's permissions for the list.\n     * @param {ListService} listService List listService.\n     * @param {Query} query Valid query object.\n     * @param {Element} responseXML XML response from the server.\n     * @param {T[]} cache Cache to process in order to handle deletions.\n     */\n    processChangeTokenXML<T extends ListItem<any>>(listService: ListService<T>, query: Query<T>, responseXML: Element): void {\n        if (!listService.listDefinitionExtended) {\n            // extend our local list definition and field definitions with XML\n            extendListMetadata(listService, responseXML);\n\n            /**If loaded from local or session cache the list/field definitions won't be extended so ensure we check before\n             * resolving observable verifying list has been extended.  One of the attributes we'd expect to see on all List/Libraries\n             * is \"BaseType\" */\n            if (listService && listService.hasOwnProperty('BaseType')) {\n                // list successfully extended\n                listService.listDefinitionExtended = Observable.create(listService);\n            }\n        }\n\n        /** Store token for future web service calls to return changes */\n        let changeToken = this.retrieveChangeToken(responseXML);\n        if (changeToken) {\n            /** Don't update change token if request fails to return a valid response */\n            query.changeToken = changeToken;\n        }\n\n        /** Update the currentPerson permissions for this list */\n        let permissions = this.retrieveListPermissions(responseXML);\n        if (permissions) {\n            listService.permissions = permissions;\n        }\n\n        /** Change token query includes deleted items as well so we need to process them separately */\n        let deletedListItems = this.getDeletionIdsSinceToken(responseXML);\n        /** Broadcast the id of any deleted list items to any subscribers */\n        deletedListItems.forEach((listItemId: number) => listService.changeTokenDeletions.next(listItemId));\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.getDeletionIdsSinceToken\n     * @description\n     * GetListItemChangesSinceToken returns items that have been added as well as deleted.  This returns an\n     * array with ID's of any list items that have been deleted since any previous requests\n     * to remove the deleted items from the local map.\n     * @param {Element} responseXML XML response from the server.\n     * @param {Object} map Cached object of key value pairs.\n     */\n    getDeletionIdsSinceToken(responseXML: Element): number[] {\n        /** Remove any locally cached entities that were deleted from the server */\n        let filteredNodes = responseXML.getElementsByTagName('Id');\n        let deletedListItems = [];\n        each(filteredNodes, (node: Element) => {\n            /** Check for the type of change */\n            let changeType = node.getAttribute('ChangeType');\n\n            if (changeType === 'Delete') {\n                let listItemId = parseInt(node.textContent, 10);\n                deletedListItems.push(listItemId);\n            }\n        });\n        return deletedListItems;\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.requestData\n     * @description\n     * The primary function that handles all communication with the server.  This is very low level and isn't\n     * intended to be called directly.\n     * @param {object} opts Payload object containing the details of the request.\n     * @returns {Observable<Document>} Observable that resolves with the server response.\n     */\n    requestData(opts: IRequestDataOptions): Observable<Document> {\n        if (!opts.operation || !opts.webURL) {\n            throw new Error('Unable to identify web service URL without a valid operation and Web URL');\n        }\n        let soapData = generateXMLComponents(opts);\n        let service = WebServiceOperationConstants[opts.operation][0];\n        let webServiceUrl = this.generateWebServiceUrl(service, opts.webURL);\n\n        let rawHeaders = <{ 'Content-Type': string; SOAPAction?: string; }>{ 'Content-Type': `text/xml;charset='utf-8'` };\n\n        if (soapData.SOAPAction) {\n            rawHeaders.SOAPAction = soapData.SOAPAction;\n        }\n        let headers = new Headers(rawHeaders);\n\n        let options = new RequestOptions({\n            headers\n        });\n\n        let request = new Request(options);\n        return this.http.post(webServiceUrl, soapData.msg, request)\n            //Try an additional time in case of initial error\n            .retry(2)\n            //Convert response to XML\n            .map((response) => {\n                let parser = new DOMParser();\n                let responseXML = parser.parseFromString(response.text(), 'application/xml');\n\n                // Success Code\n                // Errors can still be resolved without throwing an error so check the XML\n                let errorMsg = checkResponseForErrors(responseXML);\n                if (errorMsg) {\n                    // Actual error but returned with success status....thank you SharePoint\n                    errorHandler(errorMsg, soapData, responseXML);\n                }\n\n                /** Real success */\n                return responseXML;\n            });\n\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.retrieveChangeToken\n     * @description\n     * Returns the change token from the xml response of a GetListItemChangesSinceToken query\n     * Note: this attribute is only found when using 'GetListItemChangesSinceToken'\n     * @param {Element} responseXML XML response from the server.\n     */\n    retrieveChangeToken(responseXML: Element): string {\n        let changeToken: string;\n        let changeTokenElement = responseXML.getElementsByTagName('Changes');\n        if (changeTokenElement[0]) {\n            changeToken = changeTokenElement[0].getAttribute('LastChangeToken');\n        }\n        return changeToken;\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.retrieveListPermissions\n     * @description\n     * Returns the text representation of the users permission mask\n     * Note: this attribute is only found when using 'GetListItemChangesSinceToken'\n     * @param {Element} responseXML XML response from the server.\n     */\n    retrieveListPermissions(responseXML: Element): IUserPermissionsObject {\n        //Permissions will be a string of Permission names delimited by commas\n        //Example: \"ViewListItems, AddListItems, EditListItems, DeleteListItems, ....\"\n        let listItemsContainer = responseXML.getElementsByTagName('listitems');\n        let listPermissions = listItemsContainer[0] ? listItemsContainer[0].getAttribute('EffectivePermMask') : undefined;\n        let permissionObject;\n        if (isString(listPermissions)) {\n            let permissionNameArray = listPermissions.split(',');\n            permissionObject = new BasePermissionObject();\n            //Set each of the identified permission levels to true\n            each(permissionNameArray, (permission: string) => {\n                //Remove extra spaces\n                let permissionName = permission.trim();\n                //Find the permission level on the permission object that is currently set to false\n                //and set to true\n                permissionObject[permissionName] = true;\n\n                if (permissionName === 'FullMask') {\n                    //User has full rights so set all to true\n                    each(permissionObject, (propertyValue, propertyName) => {\n                        permissionObject[propertyName] = true;\n                    });\n                }\n            });\n        }\n\n        return permissionObject;\n\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.serviceWrapper\n     * @description\n     * Generic wrapper for any SPServices web service call.  The big benefit to this function is it allows us\n     * to use Observables throughout the application instead of using the promise\n     * implementation used in SPServices so we have a more consistent experience.\n     * Check http: //spservices.codeplex.com/documentation for details on expected parameters for each operation.\n     *\n     * @param {object} options Payload params that is directly passed to SPServices.\n     * @param {string} [options.filterNode] XML filter string used to find the elements to iterate over.\n     * This is typically 'z: row' for list items.\n     * @param {Function} [options.postProcess] Method to process responseXML prior to returning.\n     * @param {string} [options.webURL] Provide a web url if requesting data from a site different from the hosting site.\n     * @returns {Observable<any>} Returns an Observable which when resolved either returns clean objects parsed by the value\n     * in options.filterNode or the raw XML response if a options.filterNode\n     *\n     *      If options.filterNode is provided, returns XML parsed by node name\n     *      Otherwise returns the server response\n     */\n    serviceWrapper(options: IServiceWrapperOptions): Observable<any> {\n        let defaults = {\n            postProcess: processXML,\n            webURL: AP_CONFIG.defaultUrl\n        };\n        let opts: IServiceWrapperOptions = Object.assign({}, defaults, options);\n\n        /** Convert the xml returned from the server into an array of js objects */\n        function processXML(responseXML: Element): any {\n            if (opts.filterNode) {\n                let filteredNodes = responseXML.getElementsByTagName(opts.filterNode);\n                return xmlToJSONService.parse(filteredNodes, { includeAllAttrs: true, removeOws: false });\n            } else {\n                return responseXML;\n            }\n        }\n\n        return this.requestData(<any>opts)\n            .map(responseXML => {\n                /** Success */\n                return opts.postProcess(responseXML);\n            });\n\n\n    }\n\n    /**\n     * @ngdoc function\n     * @name DataService.startWorkflow\n     * @description\n     * Initiate a workflow for a given list item or document.  You can view additional info at\n     * [StartWorkflow](http: //spservices.codeplex.com/wikipage?title=StartWorkflow&referringTitle=Workflow).\n     * @param {object} options Configuration options.\n     * @param {string} options.item Full fileRef for the given list item/document.\n     * @param {string} options.templateId The workflow template GUID.  You can use dataService.getAvailableWorkflows\n     * to locate to appropriate one.\n     * @param {string} [options.workflowParameters='<root />'] Optionally provide paramaters to the workflow.\n     * @param {string} [options.fileRef] Optionally pass in the relative fileRef of an listItem and then we can\n     * convert it to options.item.\n     * @returns {Observable<string>} Response if there is one.\n     * @example\n     * <pre>\n     *  DataService.startWorkflow({\n     *     item: \"https: //server/site/Lists/item\" + idData + \"_.000\",\n     *     templateId: \"{c29c1291-a25c-47d7-9345-8fb1de2a1fa3}\",\n     *     workflowParameters: \"<Data><monthName>\" + txtBox.value + \"</monthName></Data>\",\n     *      ...\n     *   })\n     *   .subscribe(result => {\n     *       //Success doesn't return anything but a confirmation that it started\n     *   }, err => {\n     *       //Error\n     *   })\n     * </pre>\n     */\n    startWorkflow(options: { item: string; templateId: string; workflowParameters?: string; fileRef?: string; }): Observable<string> {\n        let defaults = {\n            operation: 'StartWorkflow',\n            item: '',\n            fileRef: '',\n            templateId: '',\n            workflowParameters: '<root />'\n        };\n        let opts: IWorkflowInitiationConfiguration = Object.assign({}, defaults, options);\n\n        /** We have the relative file reference but we need to create the fully qualified reference */\n        if (!opts.item && opts.fileRef) {\n            opts.item = this.createItemUrlFromFileRef(opts.fileRef);\n        }\n\n        return this.serviceWrapper(opts);\n    }\n\n}\n\nfunction errorHandler(errorMsg: string, soapData: Object, response?: Object) {\n    //Log error to any server side logging list\n    LoggerService.error(errorMsg, {\n        json: {\n            request: JSON.stringify(soapData, null, 2),\n            response: JSON.stringify(response, null, 2)\n        }\n    });\n\n    throw new Error(errorMsg);\n}\n\nexport interface IGetCollectionOptions {\n    filterNode?: string;\n    ID?: number;\n    groupName?: string;\n    listName?: string;\n    operation: string;\n    userLoginName?: string;\n    webURL?: string;\n}\n\nexport interface IRequestDataOptions {\n    operation: string;\n    webURL: string;\n    [key: string]: any;\n}\n\nexport interface IServiceWrapperOptions {\n    filterNode?: string;\n    listItemID?: number;\n    operation: string;\n    postProcess?: (responseXML: Object) => any;\n    webURL?: string;\n    [key: string]: any;\n}\n\nexport interface IGetFieldVersionHistoryOptions {\n    operation?: string;\n    strFieldName?: string;\n    strlistID: string;\n    strlistItemID: number;\n    webURL?: string;\n}\n\nexport interface IWorkflowDefinition {\n    instantiationUrl: string;\n    name: string;\n    templateId: string;\n}\n\ninterface IWorkflowInitiationConfiguration extends IServiceWrapperOptions {\n    item: string;\n    fileRef: string;\n}\n"]}