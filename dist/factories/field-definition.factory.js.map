{"version":3,"file":"field-definition.factory.js","sourceRoot":"","sources":["../../src/factories/field-definition.factory.ts"],"names":[],"mappings":";AAAA,gCAA4B,6BAA6B,CAAC,CAAA;AAC1D,8BAAqC,2BAA2B,CAAC,CAAA;AAEjE,8CAAqC,2CAA2C,CAAC,CAAA;AACjF,uBAAyB,QAAQ,CAAC,CAAA;AAyDlC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAiFG;AACH;IAUI,yBAAY,GAA8B;QAJ1C,eAAU,GAAG,MAAM,CAAC;QACpB,aAAQ,GAAG,KAAK,CAAC;QAIb,MAAM,CAAC,MAAM,CAAC,IAAI,EAAE,GAAG,CAAC,CAAC;QACzB,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,GAAG,IAAI,CAAC,WAAW,GAAG,+BAAa,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;QAExF,sFAAsF;QACtF,IAAI,CAAC,UAAU,GAAG,IAAI,CAAC,UAAU,IAAI,IAAI,CAAC,YAAY,CAAC;IAC3D,CAAC;IAED;;;;;;;OAOG;IACH,gDAAsB,GAAtB;QACI,MAAM,CAAC,sCAAsB,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;IACnD,CAAC;IAED;;;;;;;;;;;;;;;;;;;;;;;OAuBG;IACH,2CAAiB,GAAjB,UAAkB,QAAuB,EAAE,OAAgB;QACvD,qFAAqF;QACrF,MAAM,CAAC,mBAAU,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,IAAI,CAAC,SAAS,CAAC,QAAQ,EAAE,IAAI,EAAE,OAAO,CAAC;YACvE,sDAAsB,CAAC,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;IACpF,CAAC;IAcL,sBAAC;AAAD,CAAC,AAxED,IAwEC;AAxEY,uBAAe,kBAwE3B,CAAA","sourcesContent":["import {fromCamelCase} from '../services/utility.service';\nimport {getDefaultValueForType} from '../services/field.service';\nimport {ListItem} from '../factories';\nimport {getFormattedFieldValue} from '../services/formatted-field-value.service';\nimport {isFunction} from 'lodash';\n// import {isFunction} from 'lodash';\n// import * as _ from 'lodash';\n// let isFunction = require('lodash/isFunction');\n\nexport interface XMLFieldDefinition {\n    Choices?: string[];\n    ColName?: string;\n    Description?: string;\n    DisplayName?: string;\n    EnforceUniqueValues?: string;\n    FillInChoice?: string;\n    Filterable?: string;\n    Format?: string;\n    Hidden?: string;\n    ID?: string;\n    Indexed?: string;\n    List?: string;\n    Name?: string;\n    NumLines?: string;\n    ReadOnly?: string;\n    RelationshipDeleteBehavior?: string;\n    Required?: string;\n    ResultType?: string;\n    RichText?: string;\n    RowOrdinal?: string;\n    ShowField?: string;\n    Sortable?: string;\n    SourceID?: string;\n    StaticName?: string;\n    Type?: string;\n}\n\nexport interface IFieldConfigurationObject {\n    choices?: string[];\n    description?: string;\n    displayName?: string;\n    formatter?: (listItem: ListItem<any>, fieldDefinition: IFieldDefinition, options?: Object) => string;\n    label?: string;\n    //JS property name that we use to store the value for this field.\n    mappedName: string;\n    objectType: string;\n    readOnly?: boolean;\n    required?: boolean;\n    // Required?: boolean;\n    staticName: string;\n    [key: string]: any;\n}\n\n// an extended field definition combines the currentPerson defined field definition with the XML returned by SharePoint\nexport interface IFieldDefinition extends XMLFieldDefinition, IFieldConfigurationObject {\n    getDefaultValueForType(): any;\n    getFormattedValue(listItem: ListItem<any>, options?: Object): string;\n    // getMockData(options): any;\n}\n\n\n/**\n * @ngdoc object\n * @name Field\n * @description\n * Defined in the MODEL.fieldDefinitions array.  Each field definition object maps an internal field\n * in a SharePoint list/library to a JavaScript object using the internal SharePoint field name, the field\n * type, and the desired JavaScript property name to add onto the parsed list item object. Ignore shown usage,\n * each field definition is just an object within the fieldDefinitions array.\n * @param {object} obj Field definition.\n * @param {string} obj.staticName The actual SharePoint field name.\n * @param {string} [obj.objectType='Text']\n * <dl>\n *     <dt>Boolean</dt>\n *     <dd>Used to store a TRUE/FALSE value (stored in SharePoint as 0 or 1).</dd>\n *     <dt>Calc</dt>\n *     <dd>\";#\" Delimited String: The first value will be the calculated column value\n *     type, the second will be the value</dd>\n *     <dt>Choice</dt>\n *     <dd>Simple text string but when processing the initial list definition, we\n *     look for a Choices XML element within the field definition and store each\n *     value.  We can then retrieve the valid Choices with one of the following:\n *     ```var fieldDefinition = LISTITEM.getFieldDefinition('CHOICE_FIELD_NAME');```\n *                                      or\n *     ```var fieldDefinition = MODELNAME.getFieldDefinition('CHOICE_FIELD_NAME');```\n *     ```var choices = fieldDefinition.Choices;```\n *     </dd>\n *     <dt>Counter</dt>\n *     <dd>Same as Integer. Generally used only for the internal ID field. Its integer\n *     value is set automatically to be unique with respect to every other item in the\n *     current list. The Counter type is always read-only and cannot be set through a\n *     form post.</dd>\n *     <dt>Currency</dt>\n *     <dd>Floating point number.</dd>\n *     <dt>DateTime</dt>\n *     <dd>Replace dashes with slashes and the \"T\" deliminator with a space if found.  Then\n *     converts into a valid JS date object.</dd>\n *     <dt>Float</dt>\n *     <dd>Floating point number.</dd>\n *     <dt>HTML</dt>\n *     <dd>```_.unescape(STRING)```</dd>\n *     <dt>Integer</dt>\n *     <dd>Parses the string to a base 10 int.</dd>\n *     <dt>JSON</dt>\n *     <dd>Parses JSON if valid and converts into a a JS object.  If not valid, an error is\n *     thrown with additional info on specifically what is invalid.</dd>\n *     <dt>Lookup</dt>\n *     <dd>Passes string to Lookup constructor where it is broken into an object containing\n *     a \"lookupValue\" and \"lookupId\" attribute.  Inherits additional prototype methods from\n *     Lookup.  See [Lookup](#/api/Lookup) for more information.\n *     </dd>\n *     <dt>LookupMulti</dt>\n *     <dd>Converts multiple delimited \";#\" strings into an array of Lookup objects.</dd>\n *     <dt>MultiChoice</dt>\n *     <dd>Converts delimited \";#\" string into an array of strings representing each of the\n *     selected choices.  Similar to the single \"Choice\", the XML Choices are stored in the\n *     field definition after the initial call is returned from SharePoint so we can reference\n *     later.\n *     </dd>\n *     <dt>Number</dt>\n *     <dd>Treats as a float.</dd>\n *     <dt>Text</dt>\n *     <dd>**Default** No processing of the text string from XML.</dd>\n *     <dt>User</dt>\n *     <dd>Similar to Lookup but uses the \"User\" prototype as a constructor to convert into a\n *     User object with \"lookupId\" and \"lookupValue\" attributes.  The lookupId is the site collection\n *     ID for the user and the lookupValue is typically the display name.\n *     See [User](#/api/User) for more information.\n *     </dd>\n *     <dt>UserMulti</dt>\n *     <dd>Parses delimited string to returns an array of User objects.</dd>\n * </dl>\n * @param {string} obj.mappedName The attribute name we'd like to use\n * for this field on the newly created JS object.\n * @param {boolean} [obj.readOnly=false] When saving, we only push fields\n * that are mapped and not read only.\n * @param {boolean} [obj.required=false] Allows us to validate the field to ensure it is valid based\n * on field type.\n * @returns {object} Field\n *\n * @requires angularPoint.FieldDefinition\n * @constructor\n */\nexport class FieldDefinition implements IFieldDefinition {\n    displayName: string;\n    formatter: (listItem: ListItem<any>, fieldDefinition: IFieldDefinition, options?: Object) => string;\n    internalName: string;\n    label: string;\n    mappedName: string;\n    objectType = 'Text';\n    readOnly = false;\n    staticName: string;\n\n    constructor(obj: IFieldConfigurationObject) {\n        Object.assign(this, obj);\n        this.displayName = this.displayName ? this.displayName : fromCamelCase(this.mappedName);\n\n        /** Deprecated internal name and replace with staticName but maintain compatibility */\n        this.staticName = this.staticName || this.internalName;\n    }\n\n    /**\n     * @ngdoc function\n     * @name Field:getDefaultValueForType\n     * @methodOf Field\n     * @description\n     * Can return mock data appropriate for the field type, by default it dynamically generates data but\n     * the staticValue param will instead return a hard coded type specific value.\n     */\n    getDefaultValueForType(): any {\n        return getDefaultValueForType(this.objectType);\n    }\n\n    /**\n     * @ngdoc function\n     * @name Field:getFormattedValue\n     * @methodOf Field\n     * @description\n     * By default uses the formatted field service to convert a field value into a formatted string\n     * readable by user.  Optionally can override in field definition with formatter property to return\n     * custom formatted value. A good example of this would be to stringify a discussion thread.\n     * @param {ListItem<any>} listItem List used to generate field value.\n     * @param {object} [options] Pass through to FormattedFieldValueService.getFormattedFieldValue.\n     * @returns {string} Formatted field value suitable for outputting to user.\n     * @example\n     * <pre>\n     *  //In listService.customFields defining a field\n     * {\n     * \t  mappedName: 'lookup',\n     * \t  objectType: 'Lookup',\n     *    staticName: 'MyAwesomeLookup',\n     * \t  formatter: (listItem: ListItem<any>, fieldDefinition: IFieldDefinition, options?: Object) => {\n     * \t  \t return listItem[fieldDefinition.mappedName].lookupValue.toUpperCase();\n     * \t  }\n     * }\n     * </pre>\n     */\n    getFormattedValue(listItem: ListItem<any>, options?: Object): string {\n        //Optionally provide a custom method to convert a field value into a formatted string\n        return isFunction(this.formatter) ? this.formatter(listItem, this, options) :\n            getFormattedFieldValue(listItem[this.mappedName], this.objectType, options);\n    }\n\n    /**\n     * @ngdoc function\n     * @name Field:getMockData\n     * @methodOf Field\n     * @param {object} [options] Optional params passed to FieldService.getMockData.\n     * @param {boolean} [options.staticValue=false] Default to dynamically build mock data.\n     * @returns {*} mockData\n     */\n    // getMockData(options): any {\n    //     return getMockData(this.objectType, options);\n    // }\n\n}\n"]}