{"version":3,"file":"list-item.factory.js","sourceRoot":"","sources":["../../src/factories/list-item.factory.ts"],"names":[],"mappings":"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","sourcesContent":["import {resolvePermissions, registerChange} from '../services/utility.service';\nimport {generateValuePairs} from '../services/encode.service';\nimport {registerListItemUpdate} from '../services/change.service';\nimport {processListItems} from '../services/decode.service';\nimport {injector} from '../services/injector.service';\n\nimport {\n    DataService,\n    IGetFieldVersionHistoryOptions,\n    IWorkflowDefinition\n} from '../services/dataservice.service';\nimport {AP_CONFIG, IUserPermissionsObject} from '../constants';\nimport {Injectable } from '@angular/core';\nimport {\n    FieldChangeSummary,\n    VersionHistoryCollection,\n    User,\n    Lookup,\n    ListService\n} from '../factories';\nimport {ChangeSummary, FieldVersionCollection} from './list-item-version.factory';\nimport {IFieldDefinition, IFieldConfigurationObject} from './field-definition.factory';\nimport {Observable} from 'rxjs/Observable';\nimport {cloneDeep, isFunction, isNaN, isArray, isString} from 'lodash';\n\n// raw list item before passed into constructor function\nexport interface IUninstantiatedListItem {\n    author: User;\n    created: Date;\n    editor: User;\n    fileRef: Lookup<any>;\n    id: number;\n    modified: Date;\n    permMask: string;\n    uniqueId: string;\n    version?: number;\n    [key: string]: any;\n}\n\n/** standard uninstantiated list item with helper methods required to instantiate\n * with list service factory */\nexport interface IUninstantiatedExtendedListItem<T extends ListItem<any>> extends IUninstantiatedListItem {\n    getPristine?: () => Object;\n}\n\n\n/**\n * @ngdoc object\n * @name ListItem\n * @description\n * Base prototype which all list items inherit from.  All methods can be accessed\n * through this prototype so all CRUD functionality can be called directly from a given list item.\n * @constructor\n */\n@Injectable()\nexport class ListItem<T extends ListItem<any>> implements IUninstantiatedExtendedListItem<T> {\n    author: User;\n    created: Date;\n    editor: User;\n    fileRef: Lookup<T>;\n    getListService: () => ListService<T>;\n    getPristine: () => IUninstantiatedListItem;\n    id: number;\n    modified: Date;\n    permMask: string;\n    uniqueId: string;\n\n    /**\n     * @ngdoc function\n     * @name ListItem.addAttachment\n     * @description\n     * Uploads an attachment to a given list item.\n     * @param {string} attachment A base-64 encoded ASCII string.\n     * @param {string} fileName The name of the file to store in SharePoint.\n     * @returns {Observable<string>} The relative url of the new attachment.\n     */\n    addAttachment(attachment: string, fileName: string): Observable<string> {\n        const dataService = injector.get(DataService);\n        return dataService\n            .serviceWrapper({\n                operation: 'AddAttachment',\n                listName: this.getListId(),\n                listItemID: this.id,\n                fileName,\n                attachment\n            })\n            .map((responseXML: Element) => {\n                let filteredNodes = responseXML.getElementsByTagName('AddAttachmentResult');\n                return filteredNodes[0].textContent;\n            });\n    }\n\n    /**\n     * @ngdoc function\n     * @name ListItem.clone\n     * @description\n     * Create a deep copy of the current list item to prevent mutation of the \n     * original.\n     * @returns {T} Deep copy of the list item.\n     */\n    clone(): T {\n        let listService = this.getListService();\n        return listService.factory(Object.assign({}, this));\n    }\n\n    /**\n     * @ngdoc function\n     * @name ListItem.changes\n     * @description\n     * Checks a given list item compared to its pristine state and returns a field change summary\n     * with information on any significant changes to non-readonly fields.\n     * @returns {FieldChangeSummary<T>} Change summary of all fields that have been modified\n     * since last save.\n     */\n    changes(): FieldChangeSummary<T> {\n        // Instantiate a copy of the original list item for comparison\n        let pristineListItem = cloneDeep(this.getPristine());\n        if (!pristineListItem) {\n            throw new Error('Could not retrieve a pristine version of this list item.');\n        }\n        // Remove id so when we instantiate we don't register in cache\n        pristineListItem.id = undefined;\n        // Need to instantiate using the same factory as the current list item\n        let listService = this.getListService();\n        let instantiatedPristineListItem = listService.factory(pristineListItem);\n\n        return new FieldChangeSummary<T>(this, instantiatedPristineListItem);\n    }\n\n    /**\n     * @ngdoc function\n     * @name ListItem.deleteAttachment\n     * @description\n     * Delete an attachment from a list item.\n     * @param {string} url Requires the URL for the attachment we want to delete.\n     * @returns {Observable<any>} Observable which resolves without any contents once deleted.\n     * @example\n     * <pre>\n     * deleteAttachment(listItem: ListItem<any>, attachment: string) {\n     *     let confirmation = window.confirm(\"Are you sure you want to delete this file?\");\n     *     if (confirmation) {\n     *         listItem.deleteAttachment(attachment)\n     *              .subscribe(function () {\n     *                  alert(\"Attachment successfully deleted\");\n     *              });\n     *     }\n     * };\n     * </pre>\n     */\n    deleteAttachment(url: string): Observable<any> {\n        const dataService = injector.get(DataService);\n        return dataService\n            .serviceWrapper({\n                operation: 'DeleteAttachment',\n                filterNode: 'Field',\n                listItemID: this.id,\n                url,\n                listName: this.getListId()\n            });\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.deleteItem\n     * @description\n     * Deletes record directly from the object and removes record\n     * from user cache.\n     * @returns {Observable<any>} Observable which really only lets\n     * us know the request is complete.\n     * @example\n     * ```\n     * <ul>\n     *    <li *ngFor=\"let task of tasks\">\n     *        {{task.title}} <a href (click)=\"task.deleteItem()>delete</a>\n     *    </li>\n     * </ul>\n     * ```\n     * List of tasks.  When the delete link is clicked, the list item\n     * item is removed from the local cache and the view is updated to\n     * no longer show the task.\n     */\n    deleteItem(): Observable<any> {\n        let listItem = this;\n        let listService = listItem.getListService();\n\n        let config = {\n            operation: 'UpdateListItems',\n            listName: listService.getListId(),\n            batchCmd: 'Delete',\n            ID: listItem.id,\n            valuePairs: undefined,\n            webURL: listService.identifyWebURL()\n        };\n\n        /** Check to see if list item or document because documents need the \n         * FileRef as well as id to delete\n         */\n        if (listItem.fileRef && listItem.fileRef.lookupValue) {\n            let fileExtension = listItem.fileRef.lookupValue.split('.').pop();\n            if (isNaN(fileExtension)) {\n                /** File extension instead of numeric extension so it's a document\n                 * @Example\n                 * Document: \"Site/library/file.csv\"\n                 * List Item: \"Site/List/5_.000\"\n                 */\n                config.valuePairs = [['FileRef', listItem.fileRef.lookupValue]];\n\n            }\n        }\n\n        const dataService: DataService = injector.get(DataService);\n\n        return dataService.serviceWrapper(config)\n            .map((response) => {\n                /** Optionally broadcast change event */\n                registerChange(listService, 'delete', listItem.id);\n\n                /** Success */\n                return response;\n            }, (err) => {\n                let msg = 'There was an error deleting list item ' + listItem.id +\n                    ' from ' + listService.title + ' due to the following Error: ' + err;\n                throw new Error(msg);\n            });\n\n\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.getAttachmentCollection\n     * @description\n     * Requests all attachments for a given list item.\n     * @returns {Observable<string[]>} Observable which resolves with all\n     * attachments for a list item.\n     * @example\n     * <pre>\n     * //Pull down all attachments for the current list item\n     * fetchAttachments(listItem: ListItem<any>) => {\n     *     listItem.getAttachmentCollection()\n     *         .subscribe(attachments => this.attachments = attachments );\n     * };\n     * </pre>\n     */\n    getAttachmentCollection(): Observable<string[]> {\n        const dataService = injector.get(DataService);\n        return dataService\n            .getCollection({\n                operation: 'GetAttachmentCollection',\n                listName: this.getListId(),\n                webURL: this.getListService().webURL,\n                ID: this.id,\n                filterNode: 'Attachment'\n            });\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.getAvailableWorkflows\n     * @description\n     * Wrapper for DataService.getAvailableWorkflows.  Simply passes the current item in.\n     * @returns {Observable<IWorkflowDefinition[]>} Array of objects defining each of the\n     * available workflows.\n     */\n    getAvailableWorkflows(): Observable<IWorkflowDefinition[]> {\n        const dataService = injector.get(DataService);\n        return dataService.getAvailableWorkflows(this.fileRef.lookupValue);\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.getChanges\n     * @description\n     * Wrapper for listService.getListItemById.  Queries server for any changes and\n     * extends the existing list item with those changes.\n     * @returns {Observable<T>} Observable which resolves with the updated list item.\n     */\n    getChanges(): Observable<T> {\n        let listService = this.getListService();\n        return listService.getListItemById(this.id);\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.getChangeSummary\n     * @description\n     * Uses ListItem.getVersionHistory and determines what information changed between\n     * each list item version.\n     * @param {string[]} [fieldNames] An array/single string of field names on the list\n     * item to fetch a version history for.\n     * @returns {Observable<ChangeSummary<T>>} Observable which resolves with an array\n     * of list item versions.\n     * @example\n     * Assuming we have a modal form where we want to display each version of the title\n     * and project fields of a given list item.\n     * <pre>\n     * myGenericListItem.getChangeSummary(['title', 'project'])\n     *     .subscribe((changeSummary: ChangeSummary) => {\n     *            // We now have an array of every version of these fields\n     *            this.changeSummary = changeSummary;\n     *      };\n     * </pre>\n     */\n    getChangeSummary(fieldNames?: string[]): Observable<ChangeSummary<T>> {\n        return this.getVersionHistory(fieldNames)\n            .map((versionHistoryCollection: VersionHistoryCollection<T>) => {\n                return versionHistoryCollection.generateChangeSummary();\n            });\n    }\n\n    /**\n     * @ngdoc function\n     * @name ListItem.getFieldChoices\n     * @param {string} fieldName Internal field name.\n     * @description\n     * Uses the field definition defined in the list service to attempt to find the choices\n     * array for a given Lookup or MultiLookup type field.  The default value is\n     * fieldDefinition.choices which can optionally be added to a given field definition.\n     * If this isn't found, we check fieldDefinition.Choices which is populated after a\n     * GetListItemsSinceToken operation or a ListService.extendListMetadata operation.\n     * Finally if that isn't available we return an empty array.\n     * @returns {string[]} An array of choices for a Choice or MultiChoice type field.\n     */\n    getFieldChoices(fieldName: string): string[] {\n        let listItem = this;\n        let fieldDefinition = listItem.getFieldDefinition(fieldName);\n        return fieldDefinition.choices || fieldDefinition.Choices || [];\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.getFieldDefinition\n     * @description\n     * Returns the field definition from the definitions defined in the custom fields array\n     * within a list service.\n     * @example\n     * <pre>\n     * let project = {\n     *    title: 'Project 1',\n     *    location: {\n     *        lookupId: 5,\n     *        lookupValue: 'Some Building'\n     *    }\n     * };\n     *\n     * //To get field metadata\n     * let locationDefinition = project.getFieldDefinition('location');\n     * </pre>\n     * @param {string} fieldName Internal field name.\n     * @returns {object} Field definition.\n     */\n    getFieldDefinition(fieldName: string): IFieldDefinition {\n        let listItem = this;\n        return listItem.getListService().getFieldDefinition(fieldName);\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.getFieldDescription\n     * @param {string} fieldName Internal field name.\n     * @description\n     * Uses the field definition defined in the list service to attempt to find the description\n     * for a given field.  The default value is fieldDefinition.Description which is populated\n     * after a GetListItemsSinceToken operation or a ListService.extendListMetadata operation.\n     * If this isn't available we look for an optional attribute of a field\n     * fieldDefinition.description.  Finally if that have anything it returns an empty string.\n     * @returns {string} The description for a given field object.\n     */\n    getFieldDescription(fieldName: string): string {\n        let listItem = this;\n        let fieldDefinition = listItem.getFieldDefinition(fieldName);\n        return fieldDefinition.description || fieldDefinition.Description || '';\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.getFieldLabel\n     * @param {string} fieldName Internal field name.\n     * @description\n     * Uses the field definition defined in the list service to attempt to find the label for a\n     * given field.  The default value is fieldDefinition.label.  If not available it will then\n     * use fieldDefinition.DisplayName which is populated after a GetListItemsSinceToken operation\n     * or a ListService.extendListMetadata operation.  If this isn't available it will fallback\n     * to the the fieldDefinition.DisplayName which is a best guess at converting the caml case\n     * version of the mapped name using UtilityService.fromCamelCase.\n     * @returns {string} The label for a given field object.\n     */\n    getFieldLabel(fieldName: string): string {\n        let listItem = this;\n        let fieldDefinition = listItem.getFieldDefinition(fieldName);\n        return fieldDefinition.label || fieldDefinition.DisplayName || fieldDefinition.displayName;\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.getFormattedValue\n     * @description\n     * Given the attribute name on a listItem, we can lookup the field type and from there return\n     * a formatted string representation of that value.\n     * @param {string} fieldName Attribute name on the object that contains the value to stringify.\n     * @param {object} [options] Pass through to apFormattedFieldValueService.getFormattedFieldValue\n     * or any custom method specified on the field definition.\n     * @returns {string} Formatted string representing the field value.\n     */\n    getFormattedValue(fieldName: string, options?: Object): string {\n        let listItem = this;\n        let fieldDefinition = listItem.getFieldDefinition(fieldName);\n        if (!fieldDefinition) {\n            throw new Error(`A field definition for a field named ${fieldName} wasn't found.`);\n        }\n        return fieldDefinition.getFormattedValue(this, options);\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.getListId\n     * @description\n     * Allows us to reference the list ID directly from the list item.  This is added to the\n     * ListService.listService prototype in apModelFactory.\n     * @returns {string} List ID.\n     */\n    getListId(): string {\n        let listService = this.getListService();\n        return listService.getListId();\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.getVersionHistory\n     * @description\n     * Takes an array of field names, finds the version history for field, and returns a snapshot\n     * of the object at each version.  If no fields are provided, we look at the field definitions\n     * in the list service and pull all non-readonly fields.  The only way to do this that I've\n     * been able to get working is to get the version history for each field independently and\n     * then build the history by combining the server responses for each requests into a snapshot\n     * of the object.  Each version has the standard modified date but also includes a version\n     * property with the version number.\n     * @param {string[]} [properties] An array of property names on the list item\n     * that we're interested in.\n     * @returns {Observable<VersionHistoryCollection<T>>} Observable which resolves with an object\n     * with keys=version and values = ListItemVersion.\n     * @example\n     * Assuming we have a modal form where we want to display each version of the title and project\n     * fields of a given list item.\n     * <pre>\n     * myGenericListItem.getVersionHistory(['title', 'project'])\n     *     .subscribe(versionHistory => {\n     *            // We now have an array of every version of these fields\n     *            vm.versionHistory = versionHistory;\n     *      }, err => {\n     *          // Do something with the error\n     *      });\n     * </pre>\n     */\n    getVersionHistory(properties?: string[]): Observable<VersionHistoryCollection<T>> {\n        let listService = this.getListService();\n        let observables = [];\n\n        if (properties && !isArray(properties)) {\n            throw new Error('Properties are required to be formatted as an array of strings.');\n        }\n        if (!properties) {\n            /** If fields aren't provided, pull the version history for all NON-readonly fields */\n            let targetFields = listService.fields\n                .filter(fieldDefinition => fieldDefinition.readOnly === false);\n\n            properties = targetFields.map(fieldDefinition => fieldDefinition.mappedName);\n        }\n\n        /** Generate observables for each field */\n        for (let prop of properties) {\n            let fieldDefinition = this.getFieldDefinition(prop);\n\n            let payload: IGetFieldVersionHistoryOptions = {\n                operation: 'GetVersionCollection',\n                strFieldName: fieldDefinition.staticName,\n                strlistID: listService.getListId(),\n                strlistItemID: this.id\n            };\n\n            /** Manually set site url if defined, prevents SPServices from making a \n             * blocking call to fetch it.\n             */\n            if (AP_CONFIG.defaultUrl) {\n                payload.webURL = AP_CONFIG.defaultUrl;\n            }\n            const dataService = injector.get(DataService);\n            observables.push(dataService.getFieldVersionHistory(payload, fieldDefinition));\n        }\n\n        /** Pause until all requests are resolved */\n        return Observable.forkJoin(observables)\n            .map((fieldVersionCollections: FieldVersionCollection[]) => {\n\n                let versionHistoryCollection =\n                    new VersionHistoryCollection<T>(fieldVersionCollections, listService.factory);\n\n                return versionHistoryCollection;\n            });\n    }\n\n    /**\n     * @ngdoc function\n     * @name ListItem.isPristine\n     * @description\n     * Determines if a list item has changed since it was instantiated.\n     * @returns {boolean} The list item is unchanged.\n     */\n    isPristine() {\n        return !this.changes().hasMajorChanges;\n    }\n\n    /**\n     * @ngdoc function\n     * @name ListItem.resolvePermissions\n     * @description\n     * See apModelService.resolvePermissions for details on what we expect to have returned.\n     * @returns {Object} Contains properties for each permission level evaluated for current user.\n     * @example\n     * Lets assume we're checking to see if a user has edit rights for a given task list item.\n     * <pre>\n     * let canUserEdit = task => {\n     *      let userPermissions = task.resolvePermissions();\n     *      return userPermissions.EditListItems;\n     * };\n     * </pre>\n     * Example of what the returned object would look like\n     * for a site admin.\n     * <pre>\n     * userPermissions = {\n     *    \"ViewListItems\": true,\n     *    \"AddListItems\": true,\n     *    \"EditListItems\": true,\n     *    \"DeleteListItems\": true,\n     *    \"ApproveItems\": true,\n     *    \"OpenItems\": true,\n     *    \"ViewVersions\": true,\n     *    \"DeleteVersions\": true,\n     *    \"CancelCheckout\": true,\n     *    \"PersonalViews\": true,\n     *    \"ManageLists\": true,\n     *    \"ViewFormPages\": true,\n     *    \"Open\": true,\n     *    \"ViewPages\": true,\n     *    \"AddAndCustomizePages\": true,\n     *    \"ApplyThemeAndBorder\": true,\n     *    \"ApplyStyleSheets\": true,\n     *    \"ViewUsageData\": true,\n     *    \"CreateSSCSite\": true,\n     *    \"ManageSubwebs\": true,\n     *    \"CreateGroups\": true,\n     *    \"ManagePermissions\": true,\n     *    \"BrowseDirectories\": true,\n     *    \"BrowseUserInfo\": true,\n     *    \"AddDelPrivateWebParts\": true,\n     *    \"UpdatePersonalWebParts\": true,\n     *    \"ManageWeb\": true,\n     *    \"UseRemoteAPIs\": true,\n     *    \"ManageAlerts\": true,\n     *    \"CreateAlerts\": true,\n     *    \"EditMyUserInfo\": true,\n     *    \"EnumeratePermissions\": true,\n     *    \"FullMask\": true\n     * }\n     * </pre>\n     */\n    resolvePermissions(): IUserPermissionsObject {\n        return resolvePermissions(this.permMask);\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.saveChanges\n     * @description\n     * Updates record directly from the object\n     * @param {object} [options] Optionally pass params to the data service.\n     * @param {boolean} [options.updateAllCaches=false] Search through the cache for each\n     * query to ensure listItem is updated everywhere.  This is more process intensive so\n     * by default we only update the cached listItem in the cache where this listItem is\n     * currently stored.\n     * @returns {object} Observable<T> which resolved with the updated list item from the server.\n     * @example\n     * <pre>\n     * // Example of save function on a fictitious\n     * // app/tasks/tasks_modal.component.js modal form class.\n     * saveChanges(task: Task) {\n     *      task.saveChanges()\n     *          .subscribe(udpatedTask => {\n     *              // Successfully saved so we can do something\n     *              // like close form\n     *\n     *          }, err => {\n     *              // Failure\n     *\n     *          });\n     * }\n     * </pre>\n     */\n    saveChanges({valuePairs = undefined, buildValuePairs = true} = {}): Observable<T> {\n        let listService = this.getListService();\n\n        let config = {\n            batchCmd: 'Update',\n            buildValuePairs,\n            ID: this.id,\n            listName: listService.getListId(),\n            operation: 'UpdateListItems',\n            valuePairs,\n            webURL: listService.identifyWebURL()\n        };\n\n        /** Redirect if the request is actually creating a new list item.  This can\n         * occur if we create an empty item that is instantiated from the listService\n         * and then attempt to save instead of using listService.addNewItem\n         */\n        if (!this.id) {\n            return listService.addNewItem(this, { valuePairs, buildValuePairs });\n        }\n\n        if (buildValuePairs === true) {\n\n            let editableFields = listService.fields\n                .filter((fieldDefinition) => fieldDefinition.readOnly === false);\n\n            config.valuePairs = generateValuePairs(editableFields, this);\n\n        }\n\n        const dataService: DataService = injector.get(DataService);\n\n        /** Notify change service to expect a request, only useful at this point when \n         * working offline */\n        registerListItemUpdate<T>(this, config);\n\n        return dataService\n            .serviceWrapper(config)\n            .map((response: Element) => {\n                var listItems = processListItems<T>(response, listService.mapping, listService);\n\n                // Identify updated list item\n                let updatedListItem = listItems[0];\n\n                // Optionally broadcast change event\n                registerChange(listService, 'update', updatedListItem.id);\n\n                // Resolve with the updated list item\n                return updatedListItem;\n            });\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.saveFields\n     * @description\n     * Saves a named subset of fields back to SharePoint.  This is an alternative to\n     * saving all fields.\n     * @param {string[]} fieldArray Array of internal field names that should be saved\n     * to SharePoint.\n     * @param {object} [options] Optionally pass params to the data service.\n     * @returns {Observable<T>} Observable which resolves with the updated list item\n     * from the server.\n     * @example\n     * <pre>\n     * // Example of saveFields function on a fictitious\n     * // app/tasks/task_details.component.ts modal form.\n     * // Similar to saveChanges but instead we only save\n     * // specified fields instead of pushing everything.\n     * updateStatus(task: Task) {\n     *      task.saveFields(['status', 'notes'])\n     *          .subscribe(updatedTask => {\n     *              // Successfully updated the status and\n     *              // notes fields for the given task\n     *\n     *          }, err => {\n     *              // Failure to update the field\n     *\n     *          });\n     * }\n     * </pre>\n     */\n    saveFields(fieldArray: string[]): Observable<T> {\n\n        let listItem = this;\n        let listService = listItem.getListService();\n        let definitions: IFieldConfigurationObject[] = [];\n\n        if (isString(fieldArray)) {\n            throw new Error('Field names should be an array of strings instead' +\n                ' of a single string.');\n        }\n\n        /** Find the field definition for each of the requested fields */\n        for (let fieldName of fieldArray) {\n\n            let match = listService.customFields\n                .find((fieldDefinition) => fieldDefinition.mappedName === fieldName);\n\n            if (match) {\n                definitions.push(match);\n            }\n\n        }\n\n        /** Generate value pairs for specified fields */\n        let valuePairs = generateValuePairs(definitions, listItem);\n\n        return this.saveChanges({\n            buildValuePairs: false,\n            valuePairs\n        });\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.setPristine\n     * @param {ListItem} [listItem] Optionally pass list item object back to the list\n     * item constructor to run any initialization logic.  Otherwise we just overwrite\n     * existing values on the object with a copy from the original object.\n     * @description\n     * Resets all list item properties back to a pristine state but doesn't update any\n     * properties added manually to the list item.\n     */\n    setPristine(listItem?: ListItem<any>): void {\n        if (!this.id || !isFunction(this.getPristine)) {\n            throw new Error('Unable to find the pristine state for this list item.');\n        }\n        let pristineState = this.getPristine();\n\n        if (listItem) {\n            listItem.constructor(pristineState);\n        } else {\n            Object.assign(this, pristineState);\n        }\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.startWorkflow\n     * @description\n     * Given a workflow name or templateId we initiate a given workflow using\n     * DataService.startWorkflow.\n     * @param {object} options Params for method and pass through options to\n     * DataService.startWorkflow.\n     * @param {string} [options.templateId] Used to directly start the workflow without\n     * looking up the templateId.\n     * @param {string} [options.workflowName] Use this value to lookup the templateId\n     * and then start the workflow.\n     * @returns {Observable<any>} Resolves with server response.\n     */\n    startWorkflow(options: IStartWorkflowParams): Observable<any> {\n        let listItem = this;\n        const dataService = injector.get(DataService);\n\n        /** Set the relative file reference */\n        options.fileRef = listItem.fileRef.lookupValue;\n\n        if (!options.templateId && !options.workflowName) {\n            throw new Error('Either a templateId or workflowName is required to' +\n                ' initiate a workflow.');\n        } else if (options.templateId) {\n            /** The templateId is already provided so we don't need to look for it */\n            return dataService.startWorkflow(options);\n        } else {\n            /** We first need to get the template GUID for the workflow */\n            return listItem.getAvailableWorkflows()\n                .flatMap((workflows) => {\n\n                    let targetWorklow = workflows\n                        .find((workflow) => workflow.name === options.workflowName);\n\n                    if (!targetWorklow) {\n                        throw new Error(`A workflow with the name ${options.workflowName} \n                        wasn't found.  The workflows available are\n                        [${workflows.map(workflow => workflow.name).toString()}].`);\n                    }\n\n                    /** Create an extended set of options to pass any overrides to DataService */\n                    options.templateId = targetWorklow.templateId;\n\n                    return dataService.startWorkflow(options);\n\n                });\n        }\n\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name ListItem.validateEntity\n     * @description\n     * Helper function that passes the current item to ListService.validateEntity\n     * @returns {boolean} Evaluation of validity.\n     */\n    validateEntity(): boolean {\n        let listItem = this,\n            listService = listItem.getListService();\n        return listService.validateEntity(listItem);\n    }\n\n}\n\n\nexport interface IStartWorkflowParams {\n    fileRef?: string;\n    item: string;\n    templateId: string;\n    workflowName?: string;\n    workflowParameters?: string;\n}\n"]}