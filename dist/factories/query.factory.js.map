{"version":3,"file":"query.factory.js","sourceRoot":"","sources":["../../src/factories/query.factory.ts"],"names":[],"mappings":"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","sourcesContent":["import {ListService, ListItem} from '../factories';\nimport {AP_CONFIG, DefaultListItemQueryOptions} from '../constants';\nimport {Injectable} from '@angular/core';\nimport {injector} from '../services/injector.service';\nimport {DataService} from '../services/dataservice.service';\nimport {processListItems} from '../services/decode.service';\nimport {Observable} from 'rxjs/Observable';\nimport {isNaN, isDate, each, isString} from 'lodash';\n\n\nexport interface IQueryOptions {\n    force?: boolean;\n    // Only relevant if requesting a single item\n    listItemID?: number;\n    name: string;\n    operation: 'GetListItems' | 'GetListItemChangesSinceToken';\n    query?: string;\n    queryOptions?: string;\n    // Returns all items if set to 0\n    rowLimit?: number;\n    runOnce?: boolean;\n    viewFields?: string;\n    webURL?: string;\n}\n\nexport interface IQuery<T extends ListItem<any>> {\n    cacheXML?: boolean;\n    changeToken?: string;\n    force: boolean;\n    lastRun: Date;\n    listItemID?: number;\n    name: string;\n    negotiatingWithServer: boolean;\n    operation: 'GetListItems' | 'GetListItemChangesSinceToken';\n    Observable?: Observable<T[]>;\n    query?: string;\n    queryOptions?: string;\n    rowLimit?: number;\n    runOnce: boolean;\n    viewFields: string;\n    webURL?: string;\n    execute(options?: Object): Observable<T[]>;\n    getListService(): ListService<T>;\n}\n\n/**\n * @ngdoc function\n * @name Query\n * @description\n * Primary constructor that all queries inherit from. This object is a passthrough to [SPServices](http: //spservices.codeplex.com/).  All\n * options to passed through to [dataService.executeQuery](#/api/dataService.executeQuery).\n * @param {object} queryOptions Initialization parameters.\n * @param {boolean} [queryOptions.force=false] Ignore cached data and force server query.\n * @param {number} [queryOptions.listItemID] Optionally request for a single list item by id.\n * @param {boolean} [queryOptions.localStorage=false] Should we store data from this query in local storage to speed up requests in the future.\n * @param {number} [queryOptions.localStorageExpiration=86400000] Set expiration in milliseconds - Defaults to a day\n * and if set to 0 doesn't expire.  Can be updated globally using APConfig.localStorageExpiration.\n * @param {string} [queryOptions.name=primary] The name that we use to identify this query.\n * @param {string} [queryOptions.operation=GetListItemChangesSinceToken] Optionally use 'GetListItems' to\n * receive a more efficient response, just don't have the ability to check for changes since the last time\n * the query was called. Defaults to [GetListItemChangesSinceToken](http://msdn.microsoft.com/en-us/library/lists.lists.getlistitemchangessincetoken%28v=office.12%29.aspx)\n * but for a smaller payload and faster response you can use [GetListItems](http: //spservices.codeplex.com/wikipage?title=GetListItems&referringTitle=Lists).\n * @param {string} [queryOptions.query=Ordered ascending by ID] CAML query passed to SharePoint to control\n * the data SharePoint returns. Josh McCarty has a good quick reference [here](http: //joshmccarty.com/2012/06/a-caml-query-quick-reference).\n * @param {string} [queryOptions.queryOptions] SharePoint options xml as string.\n * <pre>\n * <QueryOptions>\n *    <IncludeMandatoryColumns>FALSE</IncludeMandatoryColumns>\n *    <IncludeAttachmentUrls>TRUE</IncludeAttachmentUrls>\n *    <IncludeAttachmentVersion>FALSE</IncludeAttachmentVersion>\n *    <ExpandUserField>FALSE</ExpandUserField>\n * </QueryOptions>\n * </pre>\n * @param {string} [queryOptions.rowLimit] The number of list items to return, 0 returns all list items.\n * @param {boolean} [queryOptions.runOnce] Pertains to GetListItems only, optionally run a single time and return initial value for all future\n * calls.  Works well with data that isn't expected to change throughout the session but unlike localStorage or sessionStorage\n * the data doesn't persist between sessions.\n * @param {boolean} [queryOptions.sessionStorage=false] Use the browsers sessionStorage to cache the list items and uses the\n * queryOptions.localStorageExpiration param to validate how long the cache is good for.\n * @param {string} [queryOptions.viewFields] XML as string that specifies fields to return.\n * @param {string} [queryOptions.webURL] Used to override the default URL if list is located somewhere else.\n * @param {object} model Reference to the parent model for the query.  Allows us to reference when out of\n * scope.\n * @example\n * <pre>\n * // Query to retrieve the most recent 25 modifications\n * model.registerQuery({\n *    name: 'recentChanges',\n *    rowLimit: 25,\n *    query: '' +\n *        '<Query>' +\n *        '   <OrderBy>' +\n *        '       <FieldRef Name=\"Modified\" Ascending=\"FALSE\"/>' +\n *        '   </OrderBy>' +\n *            // Prevents any records from being returned if user\n *            // doesn't have permissions on project\n *        '   <Where>' +\n *        '       <IsNotNull>' +\n *        '           <FieldRef Name=\"Project\"/>' +\n *        '       </IsNotNull>' +\n *        '   </Where>' +\n *        '</Query>'\n * });\n * </pre>\n */\n@Injectable()\nexport class Query<T extends ListItem<any>> implements IQuery<T> {\n    // reference to the most recent query when performing GetListItemChangesSinceToken\n    changeToken: string;\n    force = false;\n    getListService: () => ListService<T>;\n    // date/time last run\n    lastRun: Date;\n    listItemID: number;\n    listName: string;\n    name: string;\n    // Flag to prevent us from making concurrent requests\n    negotiatingWithServer = false;\n    /* Every time we run we want to check to update our cached data with\n     * any changes made on the server */\n    operation: 'GetListItems' | 'GetListItemChangesSinceToken';\n    observable: Observable<T[]>;\n    // Default query returns list items in ascending ID order\n    query: string = `\n        <Query>\n           <OrderBy>\n               <FieldRef Name=\"ID\" Ascending=\"TRUE\"/>\n           </OrderBy>\n        </Query>`;\n    queryOptions = DefaultListItemQueryOptions;\n    rowLimit: number;\n    runOnce = false;\n    viewFields: string;\n    webURL: string = AP_CONFIG.defaultUrl;\n\n    // Has this query been executed at least once.\n    get hasExecuted(): boolean {\n        return isDate(this.lastRun);\n    }\n\n    constructor(queryOptions: IQueryOptions, listService: ListService<T>, viewFields: string) {\n        this.viewFields = viewFields;\n        this.listName = listService.getListId();\n        //Allow all values on query to be overwritten by queryOptions object\n        Object.assign(this, queryOptions);\n\n        // Allow the listService to be referenced at a later time\n        this.getListService = () => listService;\n    }\n\n\n    /**\n     * @ngdoc function\n     * @name Query.execute\n     * @methodOf Query\n     * @description\n     * Query SharePoint, pull down all initial records on first call along with list definition if using\n     * \"GetListItemChangesSinceToken\".  Note: this is  substantially larger than \"GetListItems\" on first call.\n     * Subsequent calls pulls down changes (Assuming operation: \"GetListItemChangesSinceToken\").\n     * @returns {Observable<T[]>} Observable that resolves with the cache for this query.\n     */\n    execute(): Observable<T[]> {\n\n        /* Return existing observable if request is already underway or has been previously executed in the past\n         * 1/10th of a second */\n        if (this.negotiatingWithServer || (this.hasExecuted && this.lastRun.getTime() + AP_CONFIG.queryDebounceTime > new Date().getTime())) {\n            return this.observable;\n\n        } else if (this.runOnce && this.hasExecuted) {\n            return this.observable;\n\n        } else {\n            // Set flag to prevent another call while this query is active\n            this.negotiatingWithServer = true;\n            let query = this;\n            let listService = this.getListService();\n            const dataService: DataService = injector.get(DataService);\n            this.observable = dataService.serviceWrapper(query)\n                .map((results) => {\n                    \n                    if (query.operation === 'GetListItemChangesSinceToken') {\n                        dataService.processChangeTokenXML<T>(listService, query, results);\n                    }\n\n                    // Convert the XML into JS objects\n                    var entities = processListItems<T>(results, listService.mapping, listService);\n\n                    // Set list permissions if not already set\n                    if (!listService.permissions && results.length > 0) {\n                        // Query needs to have returned at least 1 item so we can use permMask\n                        listService.extendPermissionsFromListItem(results[0]);\n                    }\n\n                    // Remove lock to allow for future requests\n                    this.negotiatingWithServer = false;\n\n                    // Set date time to allow for time based updates\n                    query.lastRun = new Date();\n\n                    // Store query completion date/time on listService to allow us to identify age of data\n                    listService.lastServerUpdate = new Date();\n\n                    return entities;\n                });\n\n            return this.observable;\n\n        }\n    }\n\n}\n"]}